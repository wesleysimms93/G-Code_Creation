
import numpy as np
import math

def next_char(char):
    # Find the next character using the ord() and chr() functions
    return chr(ord(char) + 1)

def unique_number(num1, num2):
    # Ensure the smaller number comes first
    return min(num1, num2) * 8000 + max(num1, num2)



class Point:
    def __init__(self ,x,y,z,name):
        self.x = int(x)
        self.y = int(y)
        self.z = int(z)
        self.name = int(name)

    def calculate_distance(point1, point2):
    # Calculate the Euclidean distance between two points
        distance = math.sqrt((point2.x - point1.x)**2 + (point2.y - point1.y)**2 + (point2.z - point1.z)**2)
        return distance


class line_graph:
    def __init__(self):
        self.points = []
        self.edges = {}

    def append_point(self, point):
        self.points.append(point)
        return
    
    def create_edges(self):
        for point in self.points:
            for point2 in self.points:
                if(point2.name != point.name):
                    unique_numb = unique_number(point2.name , point.name)
                    if (self.edges.get( unique_numb, -1) == -1) :
                        if(self.edges.get( unique_numb, -1) == -1):
                            print("Distance Does not exist!")
                            self.edges[unique_numb] = Point.calculate_distance(point, point2)
    
    def generate_permutations(self, points):
        # Custom function to generate permutations recursively
        def permute(current, remaining, result):
            if not remaining:
                result.append(current)
                return
            for i in range(len(remaining)):
                permute(current + [remaining[i]], remaining[:i] + remaining[i+1:], result)
        
        result = []
        permute([], points, result)
        return result

    def shortest_path(self):
        # Generate all permutations of points
        point_names = [point.name for point in self.points]
        permutations = self.generate_permutations(point_names)

        shortest_path = None
        shortest_distance = float('inf')

        # Check each permutation
        for perm in permutations:
            distance = 0
            for i in range(len(perm) - 1):
                point1 = self.get_point_by_name(perm[i])
                point2 = self.get_point_by_name(perm[i + 1])
                distance += self.calculate_distance(point1, point2)
            
            # Add distance back to the starting point to complete the loop
            point1 = self.get_point_by_name(perm[-1])
            point2 = self.get_point_by_name(perm[0])
            distance += self.calculate_distance(point1, point2)

            # Update if this path is shorter
            if distance < shortest_distance:
                shortest_distance = distance
                shortest_path = perm

        return shortest_path, shortest_distance

    def get_point_by_name(self, name):
        # Helper function to retrieve a point object by name
        for point in self.points:
            if point.name == name:
                return point
        return None






